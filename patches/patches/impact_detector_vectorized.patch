diff --git a/src/vision/dart_impact_detector.py b/src/vision/dart_impact_detector.py
index 456b919d0f1a527502547b2cd632724d28285102..1a9cc309e07f17f3e86aab79f003c690fb07afce 100644
--- a/src/vision/dart_impact_detector.py
+++ b/src/vision/dart_impact_detector.py
@@ -153,58 +153,70 @@ class DartImpactDetector:
             distance = np.sqrt(dx * dx + dy * dy)
 
             if distance < self.config.cooldown_radius_px:
                 return True
 
         return False
 
     # ... rest bleibt gleich
 
     def _find_dart_shapes(
             self,
             frame: np.ndarray,
             motion_mask: np.ndarray,
             frame_index: int,
             timestamp: float
     ) -> List[DartCandidate]:
         """Find dart-like objects in motion mask"""
 
         # Find contours
         contours, _ = cv2.findContours(
             motion_mask,
             cv2.RETR_EXTERNAL,
             cv2.CHAIN_APPROX_SIMPLE
         )
 
-        candidates = []
+        if not contours:
+            return []
 
-        for contour in contours:
-            area = cv2.contourArea(contour)
+        areas = np.fromiter(
+            (cv2.contourArea(contour) for contour in contours),
+            dtype=np.float32,
+            count=len(contours)
+        )
+        valid_indices = np.nonzero(
+            (areas >= self.config.min_area) & (areas <= self.config.max_area)
+        )[0]
 
-            # Filter by area
-            if not (self.config.min_area <= area <= self.config.max_area):
-                continue
+        if valid_indices.size == 0:
+            return []
+
+        candidates = []
+
+        for idx in valid_indices:
+            contour = contours[idx]
+            area = float(areas[idx])
 
             # Get bounding box
             x, y, w, h = cv2.boundingRect(contour)
 
             # Calculate aspect ratio
             aspect_ratio = float(w) / h if h > 0 else 0
 
             # Filter by aspect ratio (darts are elongated)
             if not (self.config.min_aspect_ratio <= aspect_ratio <= self.config.max_aspect_ratio):
                 continue
 
             # Calculate center
             M = cv2.moments(contour)
             if M['m00'] == 0:
                 continue
 
             cx = int(M['m10'] / M['m00'])
             cy = int(M['m01'] / M['m00'])
 
             # Calculate confidence based on shape quality
             # Darts have low circularity (elongated shape)
             perimeter = cv2.arcLength(contour, True)
             circularity = 4 * np.pi * area / (perimeter * perimeter) if perimeter > 0 else 0
 
             # Lower circularity = higher confidence for dart 
